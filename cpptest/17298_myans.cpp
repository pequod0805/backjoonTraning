#include <bits/stdc++.h>
using namespace std;

stack<pair<int,int>> NGE; //first : value, second : address
int ans[1000005];

int main(){
    ios::sync_with_stdio();
    cin.tie();
    
    int n;
    cin >> n; // 1 <= n <= 1,000,000)(O(N * Log N + N까진 가능할듯 = N의 출력))

    //모노로그 알고리즘 : 오름차순
    for(int i=0;i<=n;i++){

        int k;
        cin >> k;
        
        if(i==n)k=1000001;//마지막 n+1번이 1,000,001이라고 하고 해당될 경우-1을 줌
        
        while(!NGE.empty() && NGE.top().first < k){
            ans[NGE.top().second] = k;//i번째의 값을 가져와야함...하지만 언제나 Top만을 볼 수 밖에 없기 때문에 안됨...
            //N^2이 가능한 이유를 생각해보자...
            //배열로 풀어야 하나?
            //First, second를 통해 주소값을 같이 넣고 해당 주소를 기억하면서
            //pop된다면 그때 마다 ans의 i주소에 값을 넣고
            //아니라면 나중에 한번에 pop하면서 해당 주소를 호출해 -1을 넣자
            //그러면 최초에 값을 받으면서 내림차순을 하는 n에 나중에 스택을 pop하면서 주소를 호출하는 n추가
            //나중에 ans를 출력하는 n까지 O(3n)이 되지 않을까?
            NGE.pop();
            //바로 직전의 6198과 같은 유형
            //새로운 값을 받을 때 이전 값보다 큰지를 판단하여
            //값을 어떻게 한다는 관점은 동일...
            //다만 다른점은 이전의 값을 보면서 더 큰 값이 없다면 -1을 출력.
            // 경우는 진짜 값이 없거나 최종 값이 -1이거나 마지막 값일 경우 = stack에 남은 수 전부는
            //n+1연산으로 최대값보다 큰 값을 넣어서 -1로 통일
        }
        NGE.push({k,i});
    }
    for(int i=0; i<n;i++){
        if(ans[i]==1000001)
        {cout << "-1 ";}
        else{cout<<ans[i]<<" ";}}
}

//틀렸음...답은 맞는데...반례가 있나봄 10분만 생각해보고 답보러가기
//답을 봤는데 내가 더 잘짠 거 같아서 다시 확인...
//이전 6198에서는 같은 높이의 건물 옥상을 볼 수 있었는데 
//이번 문제는 같은 값을 받았을 때...값이 -1로 입력되어야 함
//while문의 조건이 <= 가 아니아 < 으로 변경
//이후 정답