// Authored by : unluckyjung
// Co-authored by : BaaaaaaaaaaarkingDog
// http://boj.kr/a84f083cdee3436f9f46acdef175e55f

#include <bits/stdc++.h>
using namespace std;

#define ll long long

stack<int> s;
int n;
ll ans;

int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);

  cin >> n;
  ll h;
  while (n--) {
    cin >> h;
    while(!s.empty() && s.top() <= h)// (Stack S가 비어 있지 않고 && S.top()이 입력받은 h보다 작다면) s.pop()
      s.pop();
    // 위 부분에 대한 해석 : Stack이 비어있지 않다...값이 이미 있다?
    // 값이 있는 강황에서 새로 들어온 h의 값이 나보다 크다면 조건에 맞지 않을 때까지 pop...
    ans += s.size(); // long long인 ans에다가 Stack s의 크기를 더 함...
    s.push(h); //h를 push...
  }
  cout << ans; //모든 size를 더한 값을 출력
  return 0;
}

//타임라인 별로 봅시다...예제는 6과 10, 3, 7, 4, 12, 2 => {0 += 1 += 1 += 2 += 0 += 1} == 5
//10을 입력 받았고
//이건 조건문에 맞지 않으니 그냥 넘어감
//이때 Size는 0이니 ans+=0...
//Stack에 10을 Push...
//다음 값 3을 입력받음
//Stack에 10이 있으니 !empty 는 통과인데 (10 <= 3) false
//그대로 넘어가고 ans += 1 해서 현재 ans == 1
//다음 값은 7, 조건 두개 다 통과 pop을 진행, 3이 pop되어서 10만 남음
//size는 1이 됨 (ans += 1) ans == 2
//7을 push해서 10,7이 있음
//다음값은 4, (7<4)가 성립하지 않아 패스
//size는 2, ans += 2, ans == 4가 됨
//4를 push, 다음 값은 12, 12는 조건을 모두 만족
//차례대로 4, 7, 10이 pop이후 값이 없기 때문에 !empty에서 0을 반환
//size는 0이고 ans += 0, ans == 4
//12를 push 하고 새로운 값 2를 추가
//while문은 10 <= 2가 성립하지 않으니 넘어가고
//size가 1이기 때문에 ans += 1, ans == 5
//n끝났고 나오면서 ans == 5 출력하며 종료

//자 그런데~ 여기서 문제
//  
//               = 
//   =           = 
//   =     -     = 
//   =     =     =      -> 관리인이 보는 방향
//   =  -  =  =  =   
//   =  =  =  =  =  = 
//  [1][2][3][4][5][6]  -> 빌딩의 번호
//  10  3  7  4  12 2   -> 빌딩의 높이

//라면 사실 10에서 3,7,4가 보이니까 +=3이 되어야 하고
//더해진 값은 각각 3 0 1 0 1 = 5
//그렇다면 새롭게 추가되는 값을 기준으로 보지만...연산이 방법이 다르다는 건데...
//관점이 다른 것 같다, 답을 보고 관점을 다시 찾자

//while(s.top() <= h){s.pop()} : 입력받은 값을 기준으로 내 왼쪽의 값이 나보다 작다면 지우고...나를 보고있는 빌딩을 제거...왼쪽의 값이 나보다 작다면 나를 보지 못한다는 의미...여기서 ans는 나를 볼 수 있는 빌딩의 갯수
//근데 이 경우에는 이전에 pop된 값은 없어지는 건데 나를 보고있다고 판단할 수 없다....
//!empty : 
//처음이 아니라 마지막에 s.push() : 
//왜 Long Long? :

//이해 완료 :
//일단 내가 최초에 생각한건 잘못된 게 맞았다
//다 받은 뒤 연산하려면 시간 초과된다 N(N + Log N).


//나의 문제는 두가지.

//1. 관점을 최초에 내가 보이는 빌딩으로 잡았는데, 나를 볼 수 있는 빌딩으로 잡아야 한다.
//while(!s.empty() && s.top() <= h) s.pop(); 는 나의 이전에서 나를 볼 수 있는지 판단해야하는 빌딩들을
//내림차 순으로 정리하기 위해서 정리하되 10 3 7 같이 중간에 껴서 
//내림차순으로 스택에 추가될 때 유효하지 않은 값을 찾기 위한 식입니다.

//2. ans에 값을 넣을 때 long long으로 넣어야 하는데
//경우의 수가 80000개 라면 최대 n^2 = 6,400,000,000 > int의 최대 값 (2억 어쩌고)
//C# 에서는 bigintegrt로 해결했는데, C++의 long long의 범위에서 성공